# FlowMail v1 â€” Coding Agent Implementation Prompts
*Transform Email Agent into FlowMail: Smart Email Flow Management*

---

## ðŸŽ¯ Project Overview

**Objective**: Transform Email Agent into FlowMail - a smart email flow management system that scores emails by attention urgency, proposes bulk actions, and provides safe automation with undo capabilities.

**Core Innovation**: FlowMail focuses on **timing over taxonomy** - when emails need attention rather than what category they belong to. This creates immediate value while building on existing categorization infrastructure.

**Existing Assets**: Email Agent has Gmail sync, categorization, action engine, database models, API layer, and frontend foundation. We're adding attention scoring, flow modes, and enhanced UI.

**Modular and Extensible**: Email Agent should be modular and extensible to allow for future features and integrations using Machine Learning & GENAI capabilities to drive the flow actions and automation of emails

**Focus on User Value**: FlowMail should provide immediate value to users - not just a new way to categorize emails.

**Safe Automation**: All actions should be reversible with an undo capability.

**Mobile First**: FlowMail should be optimized for mobile devices with a progressive web app (PWA) capability.

**Iterative Development**: Each increment represents a complete user experience that can be tested independently. We start with heuristics and gradually enhance with ML/GenAI.

---

## ðŸ“Š Current Email Agent Infrastructure

### âœ… Already Built & Working
- **Gmail Integration**: Full OAuth + sync with historyId optimization
- **Email Categorization**: ML + rule-based system with 8+ categories  
- **Action Engine**: Complete backend for automated actions (archive/trash)
- **Database Models**: Email, User, Category, Action Rules, Operations
- **API Layer**: 10+ routers with 50+ endpoints
- **Frontend Foundation**: Next.js + React + Tailwind
- **Authentication**: OAuth flow with session management

### ðŸ”„ Ready for Enhancement
- **Email Model**: Add `attention_score` field
- **Action Engine**: Extend with flow modes (Manual/Assist/Auto)
- **UI Components**: Transform into flow-focused interface
- **Analytics**: Add attention-based metrics

---

## ðŸ›  User Value Increments

### Increment 1: "See Your Email Priority" - Basic Attention Scoring
**User Value**: Users can immediately see which emails need their attention based on smart scoring.

#### Prompt 1.1: Add Attention Score Database Field
**Goal**: Add database foundation for attention scoring.

**Atomic Change**:
1. Create Alembic migration to add `attention_score` FLOAT column to emails table with default 0.0
2. Update Email model to include attention_score field
3. Add database index for efficient querying by attention score

**Testing Instructions**:
```bash
# Run migration
cd backend && alembic upgrade head

# Verify column exists
docker exec postgres_db psql -U postgres -d email_agent_db -c "\d emails"

# Run existing tests to ensure no regressions
pytest backend/tests/ -v
```

**Expected Result**: 
- New `attention_score` column in emails table
- All existing tests pass
- No functional changes to existing code

---

#### Prompt 1.2: Create Basic Attention Scoring Service
**Goal**: Implement simple heuristic-based attention scoring.

**Atomic Change**:
1. Create `backend/app/services/attention_scoring.py` with basic scoring function
2. Implement simple heuristic: base score 50 + urgency modifiers
3. Add unit tests for scoring logic

**Scoring Logic** (Simple Heuristic):
```python
def calculate_attention_score(email):
    score = 50.0  # base score
    if email.is_read == False:
        score += 15
    if 'IMPORTANT' in email.labels:
        score += 30
    if 'STARRED' in email.labels:
        score += 20
    return min(max(score, 0.0), 100.0)
```

**Testing Instructions**:
```bash
# Run new tests
pytest backend/tests/test_attention_scoring.py -v

# Test scoring manually
python -c "
from backend.app.services.attention_scoring import calculate_attention_score
from backend.app.models.email import Email
# Create test email and test scoring
"
```

**Expected Result**: 
- Basic attention scoring service working
- Unit tests passing
- No integration with existing systems yet

---

#### Prompt 1.3: Integrate Attention Scoring into Email Sync
**Goal**: Calculate attention scores for new emails during sync.

**Atomic Change**:
1. Update `backend/app/services/email_sync_service.py` to calculate attention scores
2. Add attention score calculation after email is saved
3. Add integration tests for sync + scoring

**Testing Instructions**:
```bash
# Run integration tests
pytest backend/tests/test_email_sync_service.py -v

# Test with real sync
# Trigger email sync and verify attention scores are calculated
```

**Expected Result**: 
- New emails get attention scores during sync
- Existing emails remain unchanged
- Sync performance not significantly impacted

---

#### Prompt 1.4: Add Attention Score to Email API Response
**Goal**: Expose attention scores via existing email API.

**Atomic Change**:
1. Update email API responses to include attention_score field
2. Add attention score to email detail endpoints
3. Update email list endpoints to include attention scores

**Testing Instructions**:
```bash
# Test email API endpoints
pytest backend/tests/test_emails.py -v

# Test API manually
curl -X GET "http://localhost:8000/emails" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Expected Result**: 
- Email API responses include attention_score
- All existing email functionality still works
- Attention scores are returned for all email endpoints

---

#### Prompt 1.5: Create Attention Score Display Component
**Goal**: Show attention scores in existing email UI.

**Atomic Change**:
1. Create `frontend/src/components/ui/attention-score-badge.tsx` component
2. Add attention score display to existing email cards
3. Style attention score with color coding (red=high, yellow=medium, green=low)

**UI Component**:
```tsx
<AttentionScoreBadge score={email.attention_score} />
// Shows colored badge with score (e.g., ðŸ”´ 85, ðŸŸ¡ 45, ðŸŸ¢ 15)
```

**Testing Instructions**:
```bash
# Run frontend tests
npm run test -- --testPathPattern=attention-score

# Test UI manually
# Navigate to emails page and verify attention scores display
```

**Expected Result**: 
- Attention scores visible on all email cards
- Color-coded badges for quick visual scanning
- Existing email functionality unchanged

---

### Increment 2: "Organize by Urgency" - Flow Buckets
**User Value**: Users can organize emails into NOW/LATER/REFERENCE buckets based on attention scores.

#### Prompt 2.1: Create Flow Buckets API
**Goal**: Create API endpoints for flow buckets.

**Atomic Change**:
1. Create `backend/app/routers/flow_buckets.py` router
2. Implement bucket logic: NOW (attentionâ‰¥70 & unread), LATER (attentionâ‰¥30 OR high attention & read), REFERENCE (attention<30 & not trash)
3. Add bucket counts endpoint

**API Endpoints**:
```
GET /flow/buckets/now
GET /flow/buckets/later
GET /flow/buckets/reference  
GET /flow/bucket-counts
```

**Testing Instructions**:
```bash
# Test bucket endpoints
pytest backend/tests/test_flow_buckets.py -v

# Test endpoints manually
curl -X GET "http://localhost:8000/flow/bucket-counts" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Expected Result**: 
- All bucket endpoints working correctly
- Bucket counts accurate
- Returns correct emails based on attention scores

---

#### Prompt 2.2: Create Flow Bucket Navigation Component
**Goal**: Build tab navigation for flow buckets.

**Atomic Change**:
1. Create `frontend/src/components/flow/flow-bucket-tabs.tsx` component
2. Add tab navigation with NOW/LATER/REFERENCE
3. Show email counts for each bucket
4. Add active state styling

**UI Component**:
```tsx
<FlowBucketTabs 
  activeBucket="now"
  counts={{ now: 5, later: 12, reference: 45 }}
  onBucketChange={setActiveBucket}
/>
```

**Testing Instructions**:
```bash
# Test bucket navigation
npm run test -- --testPathPattern=flow-bucket-tabs

# Test UI manually
# Verify tabs show correct counts and switching works
```

**Expected Result**: 
- Tab navigation working with counts
- Smooth switching between buckets
- Visual feedback for active bucket

---

#### Prompt 2.3: Create Flow Email List Component
**Goal**: Display emails in flow bucket format.

**Atomic Change**:
1. Create `frontend/src/components/flow/flow-email-list.tsx` component
2. Display emails with attention scores prominently
3. Add flow-specific email card layout
4. Include pagination for large email sets

**UI Component**:
```tsx
<FlowEmailList 
  emails={bucketEmails}
  bucketType="now"
  onEmailClick={handleEmailClick}
/>
```

**Testing Instructions**:
```bash
# Test email list component
npm run test -- --testPathPattern=flow-email-list

# Test UI manually
# Verify emails display correctly in each bucket
```

**Expected Result**: 
- Emails display with attention scores
- Flow-optimized layout
- Pagination works correctly

---

#### Prompt 2.4: Create Flow Dashboard Page
**Goal**: Combine bucket navigation and email list into complete dashboard.

**Atomic Change**:
1. Create `frontend/src/app/flow/page.tsx` main dashboard
2. Integrate bucket tabs and email list
3. Add loading states and error handling
4. Implement bucket switching logic

**Testing Instructions**:
```bash
# Test flow dashboard
npm run test -- --testPathPattern=flow-dashboard

# Test UI manually
# Navigate to /flow and test complete bucket experience
```

**Expected Result**: 
- Complete flow dashboard working
- Can switch between buckets
- Loading states and error handling
- Responsive design

---

### Increment 3: "Smart Suggestions" - Action Recommendations
**User Value**: Users get intelligent suggestions for bulk actions on low-priority emails.

#### Prompt 3.1: Add Flow Mode to User Model
**Goal**: Track user's flow mode preference.

**Atomic Change**:
1. Create Alembic migration to add `flow_mode` VARCHAR(10) to users table (default 'MANUAL')
2. Update User model to include flow_mode field
3. Add simple enum for flow modes: MANUAL, ASSIST, AUTO

**Testing Instructions**:
```bash
# Run migration
cd backend && alembic upgrade head

# Verify column exists
docker exec postgres_db psql -U postgres -d email_agent_db -c "\d users"

# Run user model tests
pytest backend/tests/test_user.py -v
```

**Expected Result**: 
- New `flow_mode` column in users table
- User model supports flow mode
- All existing tests pass

---

#### Prompt 3.2: Create Basic Suggestion Engine
**Goal**: Implement simple rule-based suggestion generation.

**Atomic Change**:
1. Create `backend/app/services/suggestion_engine.py` with basic rules
2. Implement SWEEP suggestion (bulk delete low-attention emails)
3. Add suggestion model and database table

**Suggestion Logic** (Simple Rule):
```python
def generate_sweep_suggestion(emails):
    low_attention_emails = [e for e in emails if e.attention_score < 20]
    if len(low_attention_emails) >= 10:
        return Suggestion(type="SWEEP", emails=low_attention_emails, confidence=0.7)
    return None
```

**Testing Instructions**:
```bash
# Run suggestion engine tests
pytest backend/tests/test_suggestion_engine.py -v

# Test suggestion generation manually
# Create test emails and verify suggestions are generated
```

**Expected Result**: 
- Basic suggestion engine working
- SWEEP suggestions generated for low-attention emails
- Suggestions stored in database

---

#### Prompt 3.3: Add Suggestion API Endpoints
**Goal**: Expose suggestions via API.

**Atomic Change**:
1. Create `backend/app/routers/suggestions.py` with suggestion endpoints
2. Add GET suggestions and POST execute/reject endpoints
3. Add suggestion API tests

**API Endpoints**:
```
GET /suggestions
POST /suggestions/{id}/execute
POST /suggestions/{id}/reject
```

**Testing Instructions**:
```bash
# Run suggestion API tests
pytest backend/tests/test_suggestions.py -v

# Test endpoints manually
curl -X GET "http://localhost:8000/suggestions" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

**Expected Result**: 
- Suggestion API endpoints working
- Can execute and reject suggestions
- All tests passing

---

#### Prompt 3.4: Create Suggestion Toast Component
**Goal**: Display suggestions as toast notifications.

**Atomic Change**:
1. Create `frontend/src/components/ui/suggestion-toast.tsx` component
2. Display suggestion details in toast format
3. Add accept/reject buttons
4. Show confidence score and email count

**UI Component**:
```tsx
<SuggestionToast 
  suggestion={suggestion}
  onAccept={handleAccept}
  onReject={handleReject}
/>
```

**Testing Instructions**:
```bash
# Test suggestion toast
npm run test -- --testPathPattern=suggestion-toast

# Test UI manually
# Verify toast appears with suggestion details
```

**Expected Result**: 
- Suggestion toasts display correctly
- Accept/reject buttons work
- Confidence scores and counts shown

---

#### Prompt 3.5: Create Flow Mode Toggle Component
**Goal**: Allow users to switch between flow modes.

**Atomic Change**:
1. Create `frontend/src/components/flow/flow-mode-toggle.tsx` component
2. Add toggle between Manual/Assist/Auto modes
3. Update dashboard to show current mode
4. Add mode-specific UI indicators

**UI Component**:
```tsx
<FlowModeToggle 
  currentMode={user.flow_mode}
  onModeChange={handleModeChange}
/>
```

**Testing Instructions**:
```bash
# Test flow mode toggle
npm run test -- --testPathPattern=flow-mode-toggle

# Test manually
# Toggle between modes and verify state changes
```

**Expected Result**: 
- Flow mode toggle working
- Mode changes persist to backend
- UI updates based on current mode

---

### Increment 4: "Smart Automation" - AI-Enhanced Features
**User Value**: Users get AI-powered insights and smarter automation with GenAI explanations.

#### Prompt 4.1: Create ML Provider Interface
**Goal**: Define interface for ML model integration.

**Atomic Change**:
1. Create `backend/app/core/interfaces/ml_provider.py` with abstract base class
2. Define basic ML provider interface
3. Add configuration structure for ML providers

**Interface Definition**:
```python
class MLProvider(ABC):
    @abstractmethod
    async def predict_attention_score(self, email_data: Dict) -> float
    @abstractmethod
    def get_provider_info(self) -> Dict
```

**Testing Instructions**:
```bash
# Run interface tests
pytest backend/tests/test_ml_provider_interface.py -v

# Verify interface can be implemented
# Create mock provider and test interface compliance
```

**Expected Result**: 
- ML provider interface defined
- Interface tests passing
- No functional changes to existing code

---

#### Prompt 4.2: Implement Mock ML Provider
**Goal**: Create a mock ML provider for testing.

**Atomic Change**:
1. Create `backend/app/ml/providers/mock_provider.py`
2. Implement mock provider that returns random scores
3. Add provider registry for easy switching

**Mock Provider Logic**:
```python
class MockMLProvider(MLProvider):
    async def predict_attention_score(self, email_data: Dict) -> float:
        return random.uniform(0.0, 100.0)
```

**Testing Instructions**:
```bash
# Test mock provider
pytest backend/tests/test_mock_ml_provider.py -v

# Test provider registry
# Verify mock provider can be registered and used
```

**Expected Result**: 
- Mock ML provider working
- Provider registry functional
- Can switch between heuristic and mock ML scoring

---

#### Prompt 4.3: Add GenAI Provider Interface
**Goal**: Define interface for GenAI service integration.

**Atomic Change**:
1. Create `backend/app/core/interfaces/genai_provider.py` with abstract base class
2. Define GenAI provider interface for content analysis
3. Add configuration structure for GenAI providers

**Interface Definition**:
```python
class GenAIProvider(ABC):
    @abstractmethod
    async def analyze_email_content(self, email_content: str) -> Dict
    @abstractmethod
    async def generate_suggestion_reason(self, suggestion: Suggestion) -> str
```

**Testing Instructions**:
```bash
# Run GenAI interface tests
pytest backend/tests/test_genai_provider_interface.py -v

# Verify interface can be implemented
# Create mock GenAI provider and test interface compliance
```

**Expected Result**: 
- GenAI provider interface defined
- Interface tests passing
- No functional changes to existing code

---

#### Prompt 4.4: Enhance Suggestion Engine with GenAI
**Goal**: Use GenAI to improve suggestion reasoning.

**Atomic Change**:
1. Update `suggestion_engine.py` to use GenAI for reasoning
2. Add GenAI-powered suggestion explanations
3. Maintain fallback to simple rules

**Testing Instructions**:
```bash
# Test enhanced suggestion engine
pytest backend/tests/test_suggestion_engine_genai.py -v

# Test suggestion explanations
# Verify suggestions now include GenAI-generated reasons
```

**Expected Result**: 
- Suggestions include GenAI-generated explanations
- Fallback to simple rules if GenAI unavailable
- Suggestion quality improved

---

#### Prompt 4.5: Create AI Insights Component
**Goal**: Display AI-powered insights in the UI.

**Atomic Change**:
1. Create `frontend/src/components/ai/ai-insights-panel.tsx` component
2. Display GenAI-generated email summaries
3. Show AI confidence scores
4. Add insights to email cards

**UI Component**:
```tsx
<AIInsightsPanel 
  email={email}
  insights={aiInsights}
  confidence={confidence}
/>
```

**Testing Instructions**:
```bash
# Test AI insights component
npm run test -- --testPathPattern=ai-insights

# Test UI manually
# Verify AI insights display correctly
```

**Expected Result**: 
- AI insights display in email cards
- GenAI summaries shown
- Confidence scores visible

---

### Increment 5: "Safe Actions" - Undo System & Activity Timeline
**User Value**: Users can safely execute actions knowing they can be undone, with full visibility into their email management history.

#### Prompt 5.1: Add Undo System Backend
**Goal**: Implement undo capability for executed suggestions.

**Atomic Change**:
1. Create `backend/app/services/undo_service.py`
2. Track executed suggestions in database
3. Implement undo API endpoints

**Undo Logic**:
- Store original email state before action
- Create inverse operation for executed action
- Sync changes back to Gmail

**Testing Instructions**:
```bash
# Test undo system
pytest backend/tests/test_undo_service.py -v

# Test undo manually
# Execute suggestion, then undo and verify state restored
```

**Expected Result**: 
- Can undo executed suggestions
- Email state properly restored
- Gmail sync works after undo

---

#### Prompt 5.2: Create Undo Button Component
**Goal**: Add undo functionality to the UI.

**Atomic Change**:
1. Create `frontend/src/components/ui/undo-button.tsx` component
2. Add undo button to suggestion toasts
3. Show undo availability status
4. Add confirmation for undo actions

**UI Component**:
```tsx
<UndoButton 
  canUndo={hasRecentAction}
  onUndo={handleUndo}
  lastAction={lastAction}
/>
```

**Testing Instructions**:
```bash
# Test undo button
npm run test -- --testPathPattern=undo-button

# Test UI manually
# Execute action and verify undo button appears
```

**Expected Result**: 
- Undo button appears after actions
- Undo functionality works correctly
- Confirmation prevents accidental undos

---

#### Prompt 5.3: Create Activity Timeline Backend
**Goal**: Track all user actions for timeline display.

**Atomic Change**:
1. Create activity tracking in database
2. Log all suggestion executions and rejections
3. Track flow mode changes
4. Add activity API endpoints

**Testing Instructions**:
```bash
# Test activity tracking
pytest backend/tests/test_activity_timeline.py -v

# Test activity logging
# Perform actions and verify they're logged
```

**Expected Result**: 
- All actions tracked in database
- Activity API returns timeline data
- No performance impact on main operations

---

#### Prompt 5.4: Create Activity Timeline Component
**Goal**: Display activity history in UI.

**Atomic Change**:
1. Create `frontend/src/components/activity/activity-timeline.tsx` component
2. Display executed suggestions and undo operations
3. Add timeline to flow dashboard
4. Show action details and timestamps

**UI Component**:
```tsx
<ActivityTimeline 
  activities={userActivities}
  onActivityClick={handleActivityClick}
/>
```

**Testing Instructions**:
```bash
# Test activity timeline
npm run test -- --testPathPattern=activity-timeline

# Test timeline display
# Execute suggestions and verify they appear in timeline
```

**Expected Result**: 
- Activity timeline displays in UI
- Shows executed suggestions and undo operations
- Timeline updates in real-time

---

#### Prompt 5.5: Create Safety Confirmation Modal
**Goal**: Add safety confirmations for destructive actions.

**Atomic Change**:
1. Create `frontend/src/components/ui/safety-confirmation-modal.tsx` component
2. Add confirmation for bulk delete actions
3. Show affected email count and details
4. Add safety warnings and explanations

**UI Component**:
```tsx
<SafetyConfirmationModal 
  action={suggestion}
  onConfirm={handleConfirm}
  onCancel={handleCancel}
/>
```

**Testing Instructions**:
```bash
# Test safety modal
npm run test -- --testPathPattern=safety-confirmation

# Test UI manually
# Try to execute destructive action and verify confirmation
```

**Expected Result**: 
- Safety confirmations for destructive actions
- Clear warnings about what will happen
- Users can cancel before execution

---

### Increment 6: "Mobile Experience" - Responsive Design & PWA
**User Value**: Users can manage emails effectively on mobile devices with a native app-like experience.

#### Prompt 6.1: Add Responsive Design to Flow Components
**Goal**: Make flow dashboard work well on mobile.

**Atomic Change**:
1. Add responsive breakpoints to flow components
2. Implement mobile-friendly navigation
3. Optimize email cards for touch interaction
4. Add mobile-specific styling

**Testing Instructions**:
```bash
# Test responsive design
npm run test -- --testPathPattern=responsive

# Test on mobile device
# Open flow dashboard on mobile and verify usability
```

**Expected Result**: 
- Flow dashboard works well on mobile
- Touch interactions are smooth
- UI adapts to different screen sizes

---

#### Prompt 6.2: Add Touch Gestures
**Goal**: Implement swipe gestures for email actions.

**Atomic Change**:
1. Create `frontend/src/components/ui/touch-gestures.tsx` component
2. Add swipe left/right for email actions
3. Implement gesture recognition
4. Add haptic feedback for mobile

**Testing Instructions**:
```bash
# Test touch gestures
npm run test -- --testPathPattern=touch-gestures

# Test on mobile device
# Verify swipe gestures work correctly
```

**Expected Result**: 
- Swipe gestures work on mobile
- Haptic feedback provides confirmation
- Gestures are intuitive and responsive

---

#### Prompt 6.3: Create PWA Manifest
**Goal**: Make FlowMail installable as a PWA.

**Atomic Change**:
1. Create `frontend/public/manifest.json` for PWA
2. Add app icons and splash screens
3. Configure PWA settings
4. Add service worker for offline capability

**Testing Instructions**:
```bash
# Test PWA installation
# Install FlowMail as PWA and verify functionality

# Run Lighthouse PWA audit
npx lighthouse --only-categories=pwa
```

**Expected Result**: 
- FlowMail can be installed as PWA
- App icons and splash screens work
- Offline capability functional

---

#### Prompt 6.4: Add Offline Email Viewing
**Goal**: Allow users to view emails when offline.

**Atomic Change**:
1. Implement service worker for email caching
2. Add offline email viewing capability
3. Cache recently viewed emails
4. Add offline status indicators

**Testing Instructions**:
```bash
# Test offline functionality
# Disconnect internet and verify offline viewing works

# Test service worker
# Verify emails are cached and accessible offline
```

**Expected Result**: 
- Can view cached emails offline
- Offline status clearly indicated
- Smooth transition between online/offline

---

#### Prompt 6.5: Optimize Mobile Performance
**Goal**: Ensure fast performance on mobile devices.

**Atomic Change**:
1. Implement virtual scrolling for large email lists
2. Optimize images and assets for mobile
3. Add lazy loading for email content
4. Optimize bundle size for mobile

**Testing Instructions**:
```bash
# Test mobile performance
# Run performance tests on mobile device

# Test virtual scrolling
# Verify smooth scrolling with 1000+ emails
```

**Expected Result**: 
- Fast loading on mobile devices
- Smooth scrolling performance
- Optimized bundle size

---

## ðŸ“ˆ Success Metrics

### Technical Metrics
- API latency <200ms median
- Test coverage â‰¥90% for new components
- Each increment can be completed and tested independently
- No regressions in existing functionality
- Mobile performance score â‰¥90

### User Experience Metrics
- Undo rate â‰¤5% of automated actions
- Suggestion acceptance â‰¥70% for high-confidence suggestions
- Flow mode adoption: 30% Manual â†’ 50% Assist â†’ 20% Auto
- User retention â‰¥80% weekly active users
- Mobile usage â‰¥40% of total usage

### Business Metrics
- Time to value <5 minutes from first login
- Email processing 10x faster than manual sorting
- User satisfaction â‰¥4.5/5 rating
- Feature usage â‰¥60% daily active users

---

## ðŸ”„ Integration Strategy

### Leveraged Components
- Gmail sync with historyId optimization
- Existing categorization system
- Action engine infrastructure
- Database models and API patterns
- Frontend foundation and components

### Minimal Changes Required
- Add attention_score to Email model
- Add flow_mode to User model
- Extend email_operations with flow tracking
- Create flow-specific UI components
- Add ML/GenAI provider interfaces

### Backward Compatibility
- All existing Email Agent features remain functional
- Users can switch between traditional and flow views
- Existing categories and rules continue to work
- Gradual migration path for existing users
- ML/GenAI features are opt-in

---

## âœ… Definition of Done

### Increment Completion Criteria
1. **Increment 1**: Users can see attention scores on all emails
2. **Increment 2**: Users can organize emails into NOW/LATER/REFERENCE buckets
3. **Increment 3**: Users get intelligent action suggestions
4. **Increment 4**: Users get AI-powered insights and explanations
5. **Increment 5**: Users can safely execute actions with undo capability
6. **Increment 6**: Users have excellent mobile experience with PWA

### End-to-End Success Criteria
- âœ… User can OAuth and immediately see email priorities
- âœ… User can organize emails into NOW/LATER/REFERENCE buckets
- âœ… User gets intelligent suggestions for bulk actions
- âœ… User gets AI-powered insights and explanations
- âœ… User can safely execute actions with full undo capability
- âœ… User has excellent experience on mobile devices
- âœ… Performance meets all KPI targets

---

## ðŸ§ª Testing Strategy

### For Each Increment
1. **Backend Tests**: Unit and integration tests for new functionality
2. **Frontend Tests**: Component and integration tests for UI
3. **Manual Testing**: Complete user journey testing
4. **Regression Tests**: Ensure no existing functionality breaks
5. **Performance Tests**: Verify performance targets are met

### Test Commands
```bash
# Run all backend tests
pytest backend/tests/ -v

# Run all frontend tests
npm run test

# Run specific test suites
pytest backend/tests/test_attention_scoring.py -v
npm run test -- --testPathPattern=flow

# Run with coverage
pytest backend/tests/ --cov=backend/app --cov-report=html
npm run test -- --coverage
```

### Manual Testing Checklist
For each increment, manually test:
- [ ] Complete user journey from start to finish
- [ ] All UI interactions work as expected
- [ ] Error states are handled gracefully
- [ ] Performance is acceptable
- [ ] Mobile experience is good (if applicable)
- [ ] No regressions in existing functionality

---

*Each increment is designed to be completed independently and provides immediate user value. The coding agent should read the memory bank files to understand the current Email Agent infrastructure before implementing each increment. Each increment should be thoroughly tested and approved before moving to the next one.*

